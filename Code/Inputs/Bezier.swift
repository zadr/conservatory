/**
The native Bezier type in Conservatory, used to represent a list of segment that make up a bezier path that can be drawn by a *Renderer*.
*/
public struct Bezier {
	fileprivate var segments = [Segment]()

	public init() {}

	public init(box: Box) {
		move(box[.left, .top])
		addLine(box[.right, .top])
		addLine(box[.right, .bottom])
		addLine(box[.left, .bottom])
		close()
	}

	/**
	Given a list of points, create a new bezier with lines drawn between each one of them. Before drawing the first line, we will move to the first point in the list, and then draw a line to the second point in the list, followed by the third point, and so on.

	- Parameter points: A list of *Point*s to draw lines between.
	- Parameter closes: If true, we close the subpath of the bezier immediately after drawing lines between all of our points. If the shape is not closed, the stroke will not be applied to the final line, although it will still show if a fill is applied.
	*/
	public init(points p: [Point], closes: Bool = true) {
		self.init()

		var points = p
		if points.isEmpty {
			return
		}

		move(points.removeFirst())

		points.forEach {
			addLine($0)
		}

		if closes {
			close()
		}
	}

	/**
	- Returns: A new Bezier generated by applying a *Transform* to every segment.
	*/
	public func apply(_ transform: Transform) -> Bezier {
		var newBezier = Bezier()
		newBezier.segments = map { (segment) in
			switch segment {
			case let .move(to):
				return .move(to.apply(transform))
			case let .line(to):
				return .line(to.apply(transform))
			case let .arc(center, radius, start, end):
				return .arc(center.apply(transform), radius, start, end)
			case let .curve(point, controlPoint1, controlPoint2):
				return .curve(point.apply(transform), controlPoint1.apply(transform), controlPoint2.apply(transform))
			case let .quadCurve(point, controlPoint):
				return .quadCurve(point.apply(transform), controlPoint.apply(transform))
			case .close:
				return .close
			}
		}

		return newBezier
	}

	/**
	Move to a new point, without drawing a line from the current point to the new point.
	*/
	public mutating func move(_ point: Point) {
		segments.append(.move(point))
	}

	/**
	Draw a line from the current point to a new point.
	*/
	public mutating func addLine(_ point: Point) {
		segments.append(.line(point))
	}

	/**
	Draw an arc *radius* units away from the *center*, from *startAngle* to *endAngle*.

	- Parameter center: the coordinate at the center of the arc
	- Parameter radius: how far away from the center coordinate the arc should be drawn
	- Parameter startAngle: the angle of a circle, in radians, to start drawing an arc at.
	- Parameter endAngle: the angle of a circle, in radians, to stop drawing an arc at.
	*/
	public mutating func addArc(_ center: Point, radius: Double, startAngle: Radian, endAngle: Radian) {
		segments.append(.arc(center, radius, startAngle, endAngle))
	}

	/**
	Draw a curve around *point* using *controlPoint1* and *controlPoint2* to smoothen the curve out
	*/
	public mutating func addCurve(_ point: Point, controlPoint1: Point, controlPoint2: Point) {
		segments.append(.curve(point, controlPoint1, controlPoint2))
	}

	/**
	Draw a quad curve around *point* using *controlPoint1* to smoothen the curve out
	*/
	public mutating func addQuadCurve(_ point: Point, controlPoint1: Point) {
		segments.append(.quadCurve(point, controlPoint1))
	}

	/**
	Closes the current bezier. A line will be drawn from the current point to the opening point to accomplish this.
	*/
	public mutating func close() {
		segments.append(.close)
	}

	/**
	Returns: The most recent *Point* that we have moved or drawn a segment at.
	*/
	public var currentPoint: Point? {
		for segment in segments.reversed() {
			switch segment {
			case let .move(to):
				return to
			case let .line(to):
				return to
			case let .arc(center, _, _, _):
				return center // return point at the end of the arc?
			case let .curve(point, _, _):
				return point
			case let .quadCurve(point, _):
				return point
			case .close:
				continue
			}
		}

		return nil
	}

	/**
	Returns: *true* if a bezier has no segments, otherwise, *false*.
	*/
	public var isEmpty: Bool {
		return segments.isEmpty
	}
}

extension Bezier: CustomStringConvertible {
	public var description: String {
		return segments.reduce("[", { (x, segment) -> String in
			return x + "\n\t\(segment)"
		}) + "\n]"
	}
}

extension Bezier: Hashable {
	public func hash(into hasher: inout Hasher) {
		hasher.combine(segments)
		_ = hasher.finalize()
	}
}

extension Bezier: Sequence {
	public func makeIterator() -> BezierSegmentIterator {
		return BezierSegmentIterator(self)
	}
}

public func ==(x: Bezier, y: Bezier) -> Bool {
	return x.segments == y.segments
}

// MARK: -

public struct BezierSegmentIterator: IteratorProtocol {
	public typealias Element = Segment

	fileprivate var segments: ArraySlice<Segment>

	init(_ bezier: Bezier) {
		segments = ArraySlice(bezier.segments)
	}

	public mutating func next() -> Element? {
		let next = segments.first
		segments = segments.dropFirst()
		return next
	}
}

// MARK: -

public enum Segment {
	case move(Point)
	case line(Point)
	case arc(Point, Double, Radian, Radian)
	case curve(Point, Point, Point)
	case quadCurve(Point, Point)
	case close
}

extension Segment: CustomStringConvertible {
	public var description: String {
		switch self {
		case let .move(to):
			return "Segment(segment: .Move(\(to)))"
		case let .line(to):
			return "Segment(segment: .Line(\(to)))"
		case let .arc(center, radius, start, end):
			return "Segment(segment: .Arc(\(center), \(radius), \(start), \(end)))"
		case let .curve(point, controlPoint1, controlPoint2):
			return "Segment(segment: .Curve(\(point), \(controlPoint1), \(controlPoint2)))"
		case let .quadCurve(point, controlPoint):
			return "Segment(segment: .QuadCurve(\(point), \(controlPoint)))"
		case .close:
			return "Segment(segment: .Close)"
		}
	}
}

extension Segment: Hashable {
	public func hash(into hasher: inout Hasher) {
		hasher.combine(description)
		_ = hasher.finalize()
	}
}

public func ==(x: Segment, y: Segment) -> Bool {
	return x.description == y.description
}
